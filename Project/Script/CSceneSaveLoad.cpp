#include "pch.h"
#include "CSceneSaveLoad.h"

#include <Engine/CSceneMgr.h>
#include <Engine/CScene.h>
#include <Engine/CLayer.h>
#include <Engine/CGameObject.h>
#include <Engine/CPrefab.h>

#include <Engine/CScript.h>
#include "CScriptMgr.h"
#include <fstream>
#include <json/reader.h>

void CSceneSaveLoad::SaveScene(CScene* _pScene, const wstring& _strSceneFilePath)
{   
    // 리소스 변경상태 저장
    CResMgr::GetInst()->SaveChangedRes();

    // Scene 저장
    FILE* pFile = nullptr;
    _wfopen_s(&pFile, _strSceneFilePath.c_str(), L"wb");

    assert(pFile);
    if (nullptr == pFile)
        return;

    // Scene 이름 저장
    _pScene->SaveToScene(pFile);

    // Scene 의 Layer 정보 저장
    for (UINT i = 0; i < MAX_LAYER; ++i)
    {
        // Layer 이름 저장
        CLayer* pLayer = _pScene->GetLayer(i);
        pLayer->SaveToScene(pFile);

        // Layer 가 보유중인 Root 오브젝트 개수 저장
        vector<CGameObject*>& vecRootObj = pLayer->GetRootObjects();
        size_t iObjCount = vecRootObj.size();
        fwrite(&iObjCount, sizeof(size_t), 1, pFile);

        // 각 루트오브젝트 저장
        for (size_t j = 0; j < vecRootObj.size(); ++j)
        {
            SaveGameObject(vecRootObj[j], pFile);
        }
    }

    fclose(pFile);
}


CScene* CSceneSaveLoad::LoadScene(const wstring& _strSceneFilePath)
{
    // 최종 경로에서 상대경로만 추출
    wstring strKey = CPathMgr::GetInst()->GetRelativePath(_strSceneFilePath);

    // CResMgr 에서 상대경로를 키값으로, CSceneFile 을 찾아냄
    CResMgr::GetInst()->Load<CSceneFile>(strKey, strKey);

    // Load 할 Scene 생성 및 파일로부터 로딩
    CScene* pLoadScene = new CScene;
    pLoadScene->SetResKey(strKey);

    FILE* pFile = nullptr;
    _wfopen_s(&pFile, _strSceneFilePath.c_str(), L"rb");

    assert(pFile);
    if (nullptr == pFile)
        return nullptr;

    // Scene 이름 불러오기
    pLoadScene->LoadFromScene(pFile);

    // Scene 의 Layer 정보 불러오기
    for (UINT i = 0; i < MAX_LAYER; ++i)
    {
        // Layer 의 이름 
        CLayer* pLayer = pLoadScene->GetLayer(i);
        pLayer->LoadFromScene(pFile);

        // Layer 보유 오브젝트 개수
        size_t iObjCount = 0;
        fread(&iObjCount, sizeof(size_t), 1, pFile);

        // Root 오브젝트
        for (size_t j = 0; j < iObjCount; ++j)
        {
            CGameObject* pLoadObj = LoadGameObject(pFile);
            pLoadScene->AddObject(pLoadObj, i);
        }
    }

    fclose(pFile);

    return pLoadScene;
}

void CSceneSaveLoad::SaveGameObject(CGameObject* _pObj, FILE* _pFile)
{
    // 이름, 상태, 컴포넌트 저장
    _pObj->SaveToScene(_pFile);

    // Script 저장
    const vector<CScript*>& vecScript = _pObj->GetScripts();
    size_t iScriptCount = vecScript.size();

    fwrite(&iScriptCount, sizeof(size_t), 1, _pFile);

    for (size_t i = 0; i < iScriptCount; ++i)
    {
        wstring strScriptName = CScriptMgr::GetScriptName(vecScript[i]);
        SaveWStringToFile(strScriptName, _pFile);
        vecScript[i]->SaveToScene(_pFile);
    }

    // Child Object
    const vector<CGameObject*>& vecChild = _pObj->GetChild();
    size_t iChildCount = vecChild.size();
    fwrite(&iChildCount, sizeof(size_t), 1, _pFile);

    for (size_t i = 0; i < iChildCount; ++i)
    {
        SaveGameObject(vecChild[i], _pFile);
    }
}

CGameObject* CSceneSaveLoad::LoadGameObject(FILE* _pFile)
{
    CGameObject* pLoadObj = new CGameObject;

    // 이름, 상태, 컴포넌트 불러오기
    pLoadObj->LoadFromScene(_pFile);

    // Script 불러오기        
     size_t iScriptCount = 0;
    fread(&iScriptCount, sizeof(size_t), 1, _pFile);

    for (size_t i = 0; i < iScriptCount; ++i)
    {
        wstring strScriptName;
        LoadWStringFromFile(strScriptName, _pFile);
        CScript* pLoadScript = CScriptMgr::GetScript(strScriptName);
        pLoadObj->AddComponent(pLoadScript);
        pLoadScript->LoadFromScene(_pFile);
    }

    size_t iChildCount = 0;
    fread(&iChildCount, sizeof(size_t), 1, _pFile);

    for (size_t i = 0; i < iChildCount; ++i)
    {
        CGameObject* pChild = LoadGameObject(_pFile);
        pLoadObj->AddChild(pChild);
    }

    return pLoadObj;
}

// ======
// Prefab
// ======
void CSceneSaveLoad::SavePrefab(CPrefab* _Prefab, const wstring& _strFilePath)
{
    FILE* pFile = nullptr;
    _wfopen_s(&pFile, _strFilePath.c_str(), L"wb");

    SaveGameObject(_Prefab->GetProto(), pFile);

    fclose(pFile);
}

int CSceneSaveLoad::LoadPrefab(CPrefab* _Prefab, const wstring& _strFilePath)
{
    FILE* pFile = nullptr;
    _wfopen_s(&pFile, _strFilePath.c_str(), L"rb");

    if (nullptr == pFile)
        return E_FAIL;

    CGameObject* pProto = LoadGameObject(pFile);
    _Prefab->SetProto(pProto);

    fclose(pFile);

    return S_OK;
}


void CSceneSaveLoad::SaveSceneToJson(CScene* _pScene, const wstring& _strSceneFilePath)
{
    // 리소스 변경상태 저장
    CResMgr::GetInst()->SaveChangedRes();

    // Scene 저장
    // Value값을 만들고 거기에 데이터를 추가
    Json::Value Root;

    FILE* pFile = nullptr;

    wchar_t szExt[50] = {};
    _wsplitpath_s(_strSceneFilePath.c_str(), nullptr, 0, nullptr, 0, nullptr, 0, szExt, 50);
    wstring strExt = szExt;

    if (strExt != L".json")
        return;

    _wfopen_s(&pFile, _strSceneFilePath.c_str(), L"wb");

    assert(pFile);
    if (nullptr == pFile)
        return;

    // 파일입력을 위해 StyledWriter를 이용
    Json::StyledWriter writer;

    //Scene 이름 저장
    _pScene->SaveJsonFile(Root);

    // Scene 의 Layer 정보 저장
    for (UINT i = 0; i < MAX_LAYER; ++i)
    {
        Json::Value Layer;

        // Layer 이름 저장
        CLayer* pLayer = _pScene->GetLayer(i);

        if (pLayer->GetName().length() <= 0)
            continue;

        pLayer->SaveJsonFile(Layer);

        // Layer 가 보유중인 Root 오브젝트 개수 저장
        vector<CGameObject*>& vecRootObj = pLayer->GetRootObjects();
        int iObjCount = vecRootObj.size();
        Layer["ObjCount"] = iObjCount;

        string LayerName;
        LayerName += "Layer";
        LayerName += to_string(i);
        LayerName += "Info";

        // 각 루트오브젝트 저장
        for (size_t j = 0; j < vecRootObj.size(); ++j)
        {
            string str = "Object";
            str += to_string(j);
            SaveGameObjectToJson(vecRootObj[j], Layer, str);
        }
        Root[LayerName] = Layer;
    }

    string str = writer.write(Root);

    fwrite(str.c_str(), str.length(), 1, pFile);

    fclose(pFile);
}

CScene* CSceneSaveLoad::LoadSceneToJson(const wstring& _strSceneFilePath)
{
    // 최종 경로에서 상대경로만 추출
    wstring strKey = CPathMgr::GetInst()->GetRelativePath(_strSceneFilePath);

    // CResMgr 에서 상대경로를 키값으로, CSceneFile 을 찾아냄
    CResMgr::GetInst()->Load<CSceneFile>(strKey, strKey);

    // Load 할 Scene 생성 및 파일로부터 로딩
    CScene* pLoadScene = new CScene;
    pLoadScene->SetResKey(strKey);

    FILE* pFile = nullptr;
    _wfopen_s(&pFile, _strSceneFilePath.c_str(), L"rb");

    assert(pFile);
    if (nullptr == pFile)
        return nullptr;

    Json::Value Root;
    string FilePath = string(_strSceneFilePath.begin(), _strSceneFilePath.end());
    std::ifstream file(FilePath, std::ifstream::binary);
    file >> Root;

    // Scene 이름 불러오기
    pLoadScene->LoadJsonFromFile(Root);
    
    // Scene 의 Layer 정보 불러오기
    for (UINT i = 0; i < MAX_LAYER; ++i)
    {
		string LayerName;
		LayerName += "Layer";
		LayerName += to_string(i);
		LayerName += "Info";
        Json::Value Layer = Root[LayerName];
        // Layer 의 이름 
        CLayer* pLayer = pLoadScene->GetLayer(i);
        pLayer->LoadJsonFromFile(Layer);

        // Layer 보유 오브젝트 개수
        size_t iObjCount = Layer["ObjCount"].asInt();

        // Root 오브젝트
        for (size_t j = 0; j < iObjCount; ++j)
        {
            string str = "Object";
            str += to_string(j);
            CGameObject* pLoadObj = LoadGameObjectToJson(Layer, str);
            pLoadScene->AddObject(pLoadObj, i);
        }
    }

    fclose(pFile);

    return pLoadScene;
}




void CSceneSaveLoad::SaveGameObjectToJson(CGameObject* _pObj, Json::Value& Root, const string& Str)
{
    Json::Value GameObject;
    _pObj->SaveJsonFile(GameObject);

    const vector<CScript*>& vecScript = _pObj->GetScripts();
    size_t iScriptCount = vecScript.size();
    GameObject["ScriptCount"] = iScriptCount;

    // 스크립트 이름
    Json::Value Script;
    for (size_t i = 0; i < iScriptCount; ++i)
    {
        wstring wstrScriptName = (CScriptMgr::GetScriptName(vecScript[i]));
        string strScriptName = string(wstrScriptName.begin(), wstrScriptName.end());
        Script.append(strScriptName);
    }
    GameObject["ScriptName"] = Script;

    //// Child Object
    const vector<CGameObject*>& vecChild = _pObj->GetChild();
    size_t iChildCount = vecChild.size();
    GameObject["ChildCount"] = iChildCount;

    for (size_t i = 0; i < iChildCount; ++i)
    {
        string str = "Child";
        str+= to_string(i);
        SaveGameObjectToJson(vecChild[i], GameObject, str);
    }
    Root[Str] = GameObject;
}

CGameObject* CSceneSaveLoad::LoadGameObjectToJson(Json::Value& Root, const string& Str)
{
    Json::Value GameObject = Root[Str];
    CGameObject* pLoadObj = new CGameObject;

    // 이름, 상태, 컴포넌트 불러오기
    pLoadObj->LoadJsonFromFile(GameObject);
    int iScriptCount = GameObject["ScriptCount"].asInt();

    Json::Value Script = GameObject["ScriptName"];

    Json::ValueIterator iter = Script.begin();

    for (; iter != Script.end(); iter++)
    {
        string strScriptName = (*iter).asString();
        wstring wstrScriptName = wstring(strScriptName.begin(), strScriptName.end());
        CScript* pLoadScript = CScriptMgr::GetScript(wstrScriptName);
        //pLoadScript->LoadJsonFromFile(*iter);
        pLoadObj->AddComponent(pLoadScript);
        
    }

    size_t iChildCount = GameObject["ChildCount"].asInt();
   

    for (size_t i = 0; i < iChildCount; ++i)
    {
        string str = "Child";
        str += to_string(i);
        CGameObject* pChild = LoadGameObjectToJson(GameObject, str);
        pLoadObj->AddChild(pChild);
    }

    return pLoadObj;
}
